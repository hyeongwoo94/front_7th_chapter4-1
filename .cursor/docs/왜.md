# 왜 SSR과 SSG가 필요한가?

## 📚 목차

1. [과제의 의도](#과제의-의도)
2. [렌더링 방식 이해하기](#렌더링-방식-이해하기)
3. [CSR의 문제점](#csr의-문제점)
4. [SSR로 해결하기](#ssr로-해결하기)
5. [SSG로 더 개선하기](#ssg로-더-개선하기)
6. [언제 무엇을 사용할까?](#언제-무엇을-사용할까)
7. [실무 적용 예시](#실무-적용-예시)
8. [결론](#결론)

---

## 과제의 의도

이 과제는 **현재 프로젝트가 CSR 방식으로만 동작하는 상태에서 시작**하여, **SSR과 SSG를 직접 구현**하며 다음을 이해하는 것입니다:

### 🎯 학습 목표

1. **CSR의 문제점을 직접 체험**
   - 초기 로딩이 느린 이유
   - SEO가 안 되는 이유
   - 소셜 공유 미리보기가 안 되는 이유

2. **SSR과 SSG가 왜 필요한지 이해**
   - 각각이 해결하는 문제
   - 어떤 상황에서 사용해야 하는지

3. **하이브리드 전략 구사**
   - 모든 페이지를 하나의 방식으로 만들지 않음
   - 각 페이지의 특성에 맞는 방식 선택

---

## 렌더링 방식 이해하기

### 기본 개념

웹 페이지를 만드는 방법은 크게 세 가지가 있습니다:

```
┌─────────────────────────────────────────────────┐
│  CSR (Client-Side Rendering)                    │
│  브라우저에서 HTML 생성                          │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  SSR (Server-Side Rendering)                    │
│  서버에서 HTML 생성 → 브라우저에 전달            │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  SSG (Static Site Generation)                   │
│  빌드 타임에 HTML 미리 생성 → 정적 파일로 제공   │
└─────────────────────────────────────────────────┘
```

### React, Vue는 모두 CSR인가?

**아니요! React와 Vue는 라이브러리일 뿐, 렌더링 방식을 결정하지 않습니다.**

#### 기본 사용법은 CSR이지만...

```javascript
// 기본적인 React 사용 (CSR)
import React from "react";
import ReactDOM from "react-dom/client";

function App() {
  return <div>Hello World</div>;
}

// 브라우저에서 렌더링 (CSR)
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

하지만 React와 Vue는 **SSR과 SSG도 가능**합니다!

#### SSR도 가능합니다

```javascript
// 서버에서 React 렌더링 (SSR)
import { renderToString } from "react-dom/server";

const html = renderToString(<App />);
// 서버에서 HTML 생성해서 보냄
```

#### SSG도 가능합니다

```javascript
// 빌드 타임에 React 렌더링 (SSG)
const html = renderToString(<App />);
fs.writeFileSync("dist/index.html", html);
```

### 프레임워크가 도와줍니다

**Next.js (React) / Nuxt.js (Vue)** 같은 프레임워크가 SSR/SSG를 쉽게 만들어줍니다:

```javascript
// Next.js 예시
// SSR: getServerSideProps
export async function getServerSideProps() { ... }

// SSG: getStaticProps
export async function getStaticProps() { ... }
```

**하지만 프레임워크 없이도 가능합니다!**

- 이 과제에서 직접 구현하는 것처럼
- React의 `renderToString` 같은 API를 사용하면 됨

### 현재 프로젝트는 어떤 방식인가?

**현재 vanilla 프로젝트는 CSR입니다!**

```html
<!-- packages/vanilla/index.html -->
<div id="root"><!--app-html--></div>
← 비어있음!
<script src="/src/main.js"></script>
```

```javascript
// packages/vanilla/src/main.js
// 브라우저에서 JavaScript 실행되어 화면을 그림
function main() {
  initRender(); // 여기서 HTML 생성
  router.start();
}
```

**문제:** 서버는 빈 HTML만 보내고, 브라우저에서 모든 것을 처리합니다.

**React 프로젝트(`packages/react`)도 현재는 CSR이지만,**

- 과제에서 SSR/SSG를 구현할 예정
- `react-dom/server`의 `renderToString` 사용 예정

---

## CSR의 문제점

### 1. 초기 로딩이 매우 느림

**실제로 무슨 일이 일어나는가?**

```
[사용자] 웹사이트 접속 (0초)
  ↓
[서버] 빈 HTML만 보냄: <div id="root"></div> (0.1초)
  ↓
[브라우저] JavaScript 파일 다운로드 시작 (0.2초)
  ↓
[브라우저] JavaScript 다운로드 완료 (2-3초) ← 여기서 대기!
  ↓
[브라우저] JavaScript 실행 (0.5초)
  ↓
[브라우저] API 호출해서 데이터 가져오기 (0.5-1초)
  ↓
[브라우저] 화면 그리기 (0.2초)
  ↓
[사용자] 드디어 화면을 볼 수 있음! (총 3-5초)
```

**체감 시간:**

| 상황 | 시간           | 사용자가 보는 것      |
| ---- | -------------- | --------------------- |
| 0초  | 페이지 접속    | 빈 화면 😑            |
| 1초  | JS 다운로드 중 | 빈 화면 + 로딩 스피너 |
| 2초  | JS 다운로드 중 | 빈 화면 + 로딩 스피너 |
| 3초  | JS 실행 중     | 빈 화면 + 로딩 스피너 |
| 4초  | API 호출 중    | 빈 화면 + 로딩 스피너 |
| 5초  | 렌더링 완료    | 드디어 화면! 😊       |

**쇼핑몰에서의 문제:**

- 사용자가 5초 기다리지 못하고 나가버림 (이탈률 증가)
- 첫 화면이 바로 안 보이면 신뢰도 하락

### 2. SEO (검색 엔진 최적화) 불가능

**검색 엔진(구글, 네이버)은 어떻게 작동하는가?**

```
[구글 봇] "https://myshop.com/products/123" 접속
  ↓
[서버] 빈 HTML 전달: <div id="root"></div>
  ↓
[구글 봇] JavaScript 실행하지 않고 HTML만 읽음
  ↓
[구글 봇] "내용이 없네? 인덱싱할 게 없어!" ❌
  ↓
[결과] 검색 결과에 나타나지 않음
```

**실제 예시:**

```html
<!-- 구글 봇이 보는 것 -->
<html>
  <head>
    <title>쇼핑몰</title>
  </head>
  <body>
    <div id="root"></div>
    ← 비어있음! 뭘 검색해야 할지 모름
  </body>
</html>
```

**쇼핑몰에서의 문제:**

- "노트북 추천"을 검색해도 우리 쇼핑몰 상품이 안 나옴
- 검색 유입 손실 → 매출 손실 💰

### 3. 소셜 미디어 공유 미리보기 없음

**카카오톡에 링크 공유할 때 무슨 일이 일어나는가?**

```
[친구] 상품 링크를 카카오톡에 공유
  ↓
[카카오톡] 링크를 크롤링 (JavaScript 실행 안 함)
  ↓
[서버] 빈 HTML 전달
  ↓
[카카오톡] <meta property="og:title"> 찾아봄
  ↓
[결과] 없음! ❌
  ↓
[카카오톡] 미리보기 없이 그냥 링크만 표시
```

**CSR에서 `<meta>` 태그를 동적으로 넣어도 소용없음:**

```javascript
// JavaScript로 동적으로 <meta> 태그 추가
document.querySelector("head").innerHTML += `
  <meta property="og:title" content="노트북 - 100만원" />
  <meta property="og:image" content="https://example.com/laptop.jpg" />
`;
```

**문제:** 카카오톡은 JavaScript를 실행하지 않아서 이 태그를 못 봄!

**CSR vs SSR 비교:**

```html
<!-- CSR: 카카오톡이 보는 것 -->
<head>
  <!-- <meta> 태그가 없음 -->
</head>

<!-- SSR: 카카오톡이 보는 것 -->
<head>
  <meta property="og:title" content="노트북 - 100만원" />
  <meta property="og:image" content="https://example.com/laptop.jpg" />
  <!-- 서버에서 미리 넣어놨기 때문에 카카오톡이 읽을 수 있음! -->
</head>
```

**쇼핑몰에서의 문제:**

- 링크 공유 시 미리보기 이미지 없음
- 제목과 설명 없어서 클릭률 저하
- SNS 마케팅 효과 없음

### 4. 느린 네트워크/저사양 기기에서 더욱 느림

**3G 네트워크 환경:**

| 단계                      | 시간                     |
| ------------------------- | ------------------------ |
| HTML 다운로드             | 0.1초                    |
| JavaScript 다운로드 (2MB) | **10-15초** ← 매우 느림! |
| JavaScript 실행           | 2-3초                    |
| API 호출                  | 1-2초                    |
| 렌더링                    | 1초                      |
| **총**                    | **15-20초** 😱           |

**고사양 PC 환경:**

- 총 3-5초 정도

**쇼핑몰에서의 문제:**

- 모바일 사용자가 많음 (3G/LTE 환경)
- 15초 기다리기 어려움
- 이탈률 급증

---

## SSR로 해결하기

### SSR이란?

**서버에서 HTML을 완성해서 보내는 방식**

```
[사용자] 웹사이트 접속
  ↓
[서버] 데이터베이스에서 상품 데이터 가져오기
  ↓
[서버] HTML 완성 (렌더링)
  <html>
    <body>
      <h1>노트북 - 100만원</h1>
      <img src="laptop.jpg" />
      ... (모든 내용이 이미 들어있음)
    </body>
  </html>
  ↓
[서버] 완성된 HTML 전달
  ↓
[사용자] 즉시 화면을 볼 수 있음! (0.5-1초)
  ↓
[브라우저] JavaScript 다운로드 후 "하이드레이션" (인터랙티브 기능 활성화)
```

### SSR의 장점

#### ✅ 1. 초기 로딩 매우 빠름

**비교:**

| 단계             | CSR             | SSR                       |
| ---------------- | --------------- | ------------------------- |
| HTML 받기        | 0.1초 (빈 HTML) | 0.1초 (완성된 HTML)       |
| JS 다운로드      | 2-3초           | 2-3초 (백그라운드)        |
| API 호출         | 0.5-1초         | 없음 (서버에서 이미 처리) |
| 렌더링           | 0.5초           | 없음 (서버에서 이미 처리) |
| **첫 화면 보임** | **3-5초**       | **0.5-1초** ✅            |

**사용자 경험:**

- 페이지 접속 즉시 내용이 보임
- 로딩 스피너 대신 실제 콘텐츠를 봄
- 이탈률 감소

#### ✅ 2. SEO 완벽

**구글 봇이 보는 것:**

```html
<!-- SSR로 생성된 HTML -->
<html>
  <head>
    <title>노트북 - 100만원 | 쇼핑몰</title>
    <meta name="description" content="최신 노트북을 특가로 만나보세요" />
  </head>
  <body>
    <h1>노트북 - 100만원</h1>
    <p>최신 노트북을 특가로 만나보세요</p>
    <img src="laptop.jpg" alt="노트북 이미지" />
    <!-- 모든 내용이 이미 들어있음! -->
  </body>
</html>
```

**구글 봇:** "오! 내용이 있네! 인덱싱하자!" ✅

**쇼핑몰에서의 효과:**

- "노트북 추천" 검색 시 우리 상품이 검색 결과에 나타남
- 검색 유입 증가 → 매출 증가 💰

#### ✅ 3. 소셜 공유 미리보기 완벽

**서버에서 `<meta>` 태그를 미리 넣어놓음:**

```html
<!-- SSR로 생성된 HTML -->
<head>
  <meta property="og:title" content="노트북 - 100만원" />
  <meta property="og:description" content="최신 노트북을 특가로!" />
  <meta property="og:image" content="https://example.com/laptop.jpg" />
</head>
```

**카카오톡이 크롤링:**

- JavaScript 실행 없이도 `<meta>` 태그를 읽을 수 있음 ✅
- 예쁜 미리보기 카드 표시

**실제 예시:**

```
카카오톡에서 공유하면:

┌─────────────────────────────┐
│ [노트북 이미지]              │
│                             │
│ 노트북 - 100만원            │
│ 최신 노트북을 특가로!        │
│                             │
│ myshop.com                  │
└─────────────────────────────┘
```

#### ✅ 4. 느린 네트워크에서도 최소한 내용은 보임

- JavaScript가 느리게 로드되어도 HTML만으로 콘텐츠는 표시됨
- 최소한 정보는 볼 수 있음

### SSR의 단점

#### ❌ 1. 서버 부하 증가

- 모든 요청마다 서버에서 렌더링 필요
- 트래픽이 많으면 서버 비용 증가
- 예: 초당 1000 요청 → 서버 CPU 80% 사용

#### ❌ 2. 응답 시간이 느려질 수 있음

- 서버에서 데이터 가져오기 + 렌더링 시간
- 데이터베이스 쿼리가 느리면 전체 응답이 느려짐
- 예: DB 쿼리가 1초 걸리면 → 사용자는 1초 기다림

#### ❌ 3. 구현 복잡도 증가

- 서버와 클라이언트 코드 분리 필요
- 하이드레이션 처리 필요
- 서버/클라이언트 상태 동기화 필요

---

## SSG로 더 개선하기

### SSG란?

**빌드 타임에 미리 모든 페이지를 HTML로 만들어두는 방식**

```
[개발자] npm run build 실행
  ↓
[빌드 프로세스] 모든 상품 데이터 가져오기
  ↓
[빌드 프로세스] 각 상품마다 HTML 파일 생성
  - dist/products/1/index.html
  - dist/products/2/index.html
  - dist/products/3/index.html
  - ... (340개 상품 = 340개 HTML 파일)
  ↓
[배포] 생성된 파일들을 서버/CDN에 배포
  ↓
[사용자] 요청 → 즉시 HTML 파일 전달 (서버 작업 없음)
```

**핵심:** 서버가 렌더링하지 않고, 이미 만들어진 파일만 전달!

### SSG의 장점

#### ✅ 1. 극도로 빠른 응답 시간

**비교:**

| 방식 | 응답 시간   | 이유                      |
| ---- | ----------- | ------------------------- |
| SSR  | 200-500ms   | 서버에서 렌더링 필요      |
| SSG  | **10-50ms** | 이미 만들어진 파일만 전달 |

**이유:**

- 서버에서 렌더링할 필요 없음
- 데이터베이스 쿼리 없음
- 단순히 파일만 읽어서 전달

**실제 예시:**

```
사용자 요청 → 서버가 파일 찾기 → 전달 (0.02초)
vs
사용자 요청 → 서버가 DB 조회 → 렌더링 → 전달 (0.3초)
```

#### ✅ 2. 서버 부하 제로

- 서버에서 렌더링하지 않음
- 단순히 파일만 전달하면 됨
- 트래픽이 많아도 서버 부하 없음

**비교:**

| 방식 | 초당 1000 요청 시    |
| ---- | -------------------- |
| SSR  | CPU 80%, 메모리 2GB  |
| SSG  | CPU 5%, 메모리 200MB |

#### ✅ 3. CDN 최적화

**CDN이란?**

- 전 세계에 분산된 서버
- 사용자와 가까운 서버에서 파일 제공

**SSG + CDN:**

```
한국 사용자 → 한국 CDN 서버 → 매우 빠름
미국 사용자 → 미국 CDN 서버 → 매우 빠름
```

**SSR:**

```
한국 사용자 → 한국 서버 → 빠름
미국 사용자 → 한국 서버 → 느림 (해외 거리)
```

#### ✅ 4. 보안

- 서버에서 데이터베이스 접근하지 않음
- 해킹 위험 감소

#### ✅ 5. SEO와 소셜 공유도 완벽

- SSR과 동일하게 완성된 HTML 제공
- 검색 엔진과 소셜 미디어 크롤러가 읽을 수 있음

### SSG의 단점

#### ❌ 1. 데이터 업데이트 시 재빌드 필요

**문제 상황:**

```
새 상품이 추가됨 → 빌드 다시 해야 함
상품 가격 변경 → 빌드 다시 해야 함
상품 삭제 → 빌드 다시 해야 함
```

**해결 방법:**

- ISR (Incremental Static Regeneration): 변경된 페이지만 재생성
- On-demand Revalidation: 필요할 때만 재생성

#### ❌ 2. 동적 콘텐츠에 부적합

- 사용자별로 다른 내용을 보여줄 수 없음
- 실시간 데이터 (예: 재고 수량) 표시 어려움

**예시:**

- ✅ "상품 상세 페이지" → SSG 가능 (상품 정보는 거의 변하지 않음)
- ❌ "장바구니 페이지" → SSG 불가능 (사용자마다 다른 내용)

#### ❌ 3. 많은 페이지가 있으면 빌드 시간 증가

- 상품이 340개 → 340개 HTML 파일 생성 (빠름)
- 상품이 10만 개 → 10만 개 HTML 파일 생성 (느림, 수 시간 걸릴 수 있음)

---

## 언제 무엇을 사용할까?

### 🎯 핵심 원칙

> **"각 페이지의 특성에 맞는 렌더링 방식을 선택하라"**
>
> 모든 페이지를 하나의 방식으로 만들 필요는 없습니다.
> 필요한 곳에 적절한 방식을 조합하는 것이 중요합니다.

### CSR을 사용해야 할 때

✅ **적합한 경우:**

| 페이지               | 이유                             |
| -------------------- | -------------------------------- |
| 관리자 페이지        | SEO 불필요, 사용자가 제한적      |
| 대시보드             | 사용자별로 다른 데이터 표시 필요 |
| 실시간 애플리케이션  | 채팅, 게임 등                    |
| 인증이 필요한 페이지 | 로그인한 사용자만 접근           |

**예시:**

- 내부 관리자 페이지
- 사용자 프로필 페이지
- 실시간 주식 차트
- 장바구니 (사용자마다 다른 내용)

### SSR을 사용해야 할 때

✅ **적합한 경우:**

| 페이지                         | 이유                            |
| ------------------------------ | ------------------------------- |
| SEO가 중요한 페이지            | 검색 유입 필요                  |
| 소셜 공유가 중요한 페이지      | 링크 공유 시 미리보기 필요      |
| 초기 로딩 속도가 중요한 페이지 | 사용자 이탈 방지                |
| 개인화된 콘텐츠                | 사용자별로 다른 내용 + SEO 필요 |

**예시:**

- 쇼핑몰 홈페이지 (검색어/필터에 따라 다른 상품 표시)
- 검색 결과 페이지
- 블로그 포스트
- 뉴스 기사

### SSG를 사용해야 할 때

✅ **적합한 경우:**

| 페이지                                      | 이유                      |
| ------------------------------------------- | ------------------------- |
| 콘텐츠가 자주 변하지 않는 페이지            | 블로그, 문서, 랜딩 페이지 |
| 매우 빠른 로딩이 필요한 페이지              | 성능이 최우선             |
| 트래픽이 많은 페이지                        | 서버 부하 최소화 필요     |
| 빌드 타임에 모든 데이터를 알 수 있는 페이지 | 상품 상세, 회사 소개 등   |

**예시:**

- 상품 상세 페이지 (과제에서 이걸 SSG로 만들 예정!)
- 블로그 포스트
- 회사 소개 페이지
- 제품 설명 페이지
- 문서 사이트 (예: Vite 공식 문서)

---

## SSR은 어떻게 사용하는가?

### SSR 구현의 전체 흐름

SSR을 구현하려면 **서버에서 HTML을 미리 만들어야** 합니다. 단계별로 살펴보겠습니다:

```
1. Express 서버 구성
   ↓
2. 요청이 오면 서버에서 데이터 가져오기
   ↓
3. 서버에서 HTML 렌더링
   ↓
4. 완성된 HTML을 클라이언트에 전달
   ↓
5. 클라이언트에서 하이드레이션 (인터랙티브 기능 활성화)
```

### 1단계: Express 서버 구성

**목적:** 서버에서 요청을 받아서 처리할 수 있도록 설정

```javascript
// packages/vanilla/server.js
import express from "express";

const app = express();

// 모든 요청을 처리
app.get("*", async (req, res) => {
  // 여기서 SSR 처리
});
```

### 2단계: 서버에서 데이터 가져오기

**목적:** 화면에 표시할 데이터를 서버에서 미리 가져옴

```javascript
// packages/vanilla/src/main-server.js
export const render = async (url, query) => {
  // URL에 따라 다른 데이터 가져오기
  if (url === "/") {
    // 홈페이지: 상품 목록 데이터
    const products = await fetchProductList(query);
    return renderHomePage(products);
  } else if (url.startsWith("/products/")) {
    // 상품 상세: 상품 상세 데이터
    const productId = extractProductId(url);
    const product = await fetchProductDetail(productId);
    return renderProductDetailPage(product);
  }
};
```

**CSR vs SSR 비교:**

```javascript
// CSR: 브라우저에서 데이터 가져오기
useEffect(() => {
  fetchProducts().then(setProducts); // 클라이언트에서 실행
}, []);

// SSR: 서버에서 데이터 가져오기
const products = await fetchProducts(); // 서버에서 실행
```

### 3단계: 서버에서 HTML 렌더링

**목적:** 데이터를 HTML 문자열로 변환

**Vanilla JavaScript 예시:**

```javascript
// packages/vanilla/src/main-server.js
export const render = async (url, query) => {
  const products = await fetchProductList(query);

  // HTML 문자열 생성
  const html = `
    <div class="product-list">
      ${products
        .map(
          (product) => `
        <div class="product-card">
          <h2>${product.name}</h2>
          <p>${product.price}원</p>
        </div>
      `,
        )
        .join("")}
    </div>
  `;

  return html;
};
```

**React 예시:**

```javascript
// packages/react/src/main-server.tsx
import { renderToString } from "react-dom/server";
import { App } from "./App";

export const render = async (url: string, query: Record<string, string>) => {
  // React 컴포넌트를 HTML 문자열로 변환
  const html = renderToString(<App url={url} query={query} />);
  return html;
};
```

### 4단계: 완성된 HTML을 클라이언트에 전달

**목적:** 서버에서 만든 HTML을 템플릿에 넣어서 전달

```javascript
// packages/vanilla/server.js
import fs from "fs";

app.get("*", async (req, res) => {
  // 1. HTML 템플릿 읽기
  const template = fs.readFileSync("index.html", "utf-8");

  // 2. 서버에서 렌더링한 HTML 생성
  const appHtml = await render(req.url, req.query);

  // 3. 초기 상태 데이터도 함께 준비
  const initialState = {
    products: await fetchProductList(req.query),
  };

  // 4. 템플릿에 삽입
  const html = template
    .replace("<!--app-html-->", appHtml)
    .replace("<!--app-head-->", `<script>window.__INITIAL_DATA__ = ${JSON.stringify(initialState)};</script>`);

  // 5. 클라이언트에 전달
  res.send(html);
});
```

**결과:**

```html
<!-- 클라이언트가 받는 HTML -->
<html>
  <head>
    <script>
      window.__INITIAL_DATA__ = {
        products: [...]
      };
    </script>
  </head>
  <body>
    <div id="root">
      <div class="product-list">
        <div class="product-card">...</div>
        <div class="product-card">...</div>
      </div>
    </div>
    <script src="/src/main.js"></script>
  </body>
</html>
```

### 5단계: 클라이언트 하이드레이션

**목적:** 서버에서 받은 HTML에 인터랙티브 기능 활성화

```javascript
// packages/vanilla/src/main.js
function main() {
  // 1. 서버에서 받은 초기 상태 복원
  const initialState = window.__INITIAL_DATA__ || {};

  if (initialState.products) {
    productStore.init(initialState.products);
  }

  // 2. 기존 DOM에 이벤트만 바인딩 (새로 그리지 않음!)
  registerAllEvents();
  router.start();
}
```

**하이드레이션이란?**

- 서버에서 이미 만든 HTML이 있음
- 클라이언트에서는 그 HTML에 이벤트만 연결
- 새로 그리지 않고 기존 DOM 활용

### SSR의 핵심 포인트

1. **서버에서 데이터를 먼저 가져옴** → API 호출이 서버에서 일어남
2. **서버에서 HTML을 만들어서 보냄** → 클라이언트는 이미 완성된 HTML을 받음
3. **클라이언트는 하이드레이션만** → 인터랙티브 기능 활성화

---

## SSG는 어떻게 사용하는가?

### SSG 구현의 전체 흐름

SSG는 **빌드 타임에 미리 HTML을 만들어두는** 방식입니다:

```
1. 빌드 스크립트 실행
   ↓
2. 모든 페이지에 필요한 데이터 가져오기
   ↓
3. 각 페이지마다 HTML 파일 생성
   ↓
4. 생성된 파일들을 디렉토리에 저장
   ↓
5. 배포 시 정적 파일로 서빙
```

### 1단계: 빌드 스크립트 준비

**목적:** 빌드할 때 실행될 스크립트 작성

```json
// packages/vanilla/package.json
{
  "scripts": {
    "build:ssg": "node static-site-generate.js"
  }
}
```

### 2단계: 모든 데이터 가져오기

**목적:** 빌드 타임에 모든 페이지에 필요한 데이터 수집

```javascript
// packages/vanilla/static-site-generate.js
async function generateStaticSite() {
  // 1. 홈페이지용 데이터
  const allProducts = await fetchAllProducts();

  // 2. 각 상품 상세 페이지용 데이터
  // (각 상품마다 상세 정보 필요)
}
```

**주의사항:**

- 빌드 타임에 **모든 데이터를 가져와야** 함
- 런타임에 데이터를 가져올 수 없음

### 3단계: 각 페이지마다 HTML 생성

**목적:** 모든 페이지를 미리 렌더링해서 HTML 파일로 저장

```javascript
// packages/vanilla/static-site-generate.js
import fs from "fs";
import path from "path";
import { render } from "./src/main-server.js";

async function generateStaticSite() {
  // 1. 홈페이지 생성
  const homeHtml = await render("/", {});
  fs.writeFileSync("dist/index.html", homeHtml);

  // 2. 모든 상품 상세 페이지 생성
  const products = await fetchAllProducts();

  for (const product of products) {
    // 각 상품마다 HTML 생성
    const productHtml = await render(`/products/${product.id}`, {});

    // 파일로 저장
    const dir = path.join("dist", "products", product.id.toString());
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(path.join(dir, "index.html"), productHtml);
  }
}
```

**결과 디렉토리 구조:**

```
dist/
  ├── index.html              (홈페이지)
  ├── products/
  │   ├── 1/
  │   │   └── index.html      (상품 1 상세)
  │   ├── 2/
  │   │   └── index.html      (상품 2 상세)
  │   ├── 3/
  │   │   └── index.html      (상품 3 상세)
  │   └── ...
  └── assets/                 (CSS, JS 등)
```

### 4단계: 정적 파일로 서빙

**목적:** 생성된 HTML 파일들을 웹 서버에서 제공

```javascript
// 서버는 단순히 파일만 전달
import express from "express";
import path from "path";

const app = express();

// 정적 파일 서빙
app.use(express.static("dist"));

app.listen(3000);
```

**동작 방식:**

```
사용자 요청: /products/1
  ↓
서버: dist/products/1/index.html 파일 찾기
  ↓
서버: 파일 그대로 전달 (렌더링 없음!)
  ↓
사용자: 즉시 HTML 받음 (10-50ms)
```

### SSG의 핵심 포인트

1. **빌드 타임에 모든 페이지 생성** → 런타임에 렌더링 안 함
2. **정적 파일로 저장** → 파일 시스템에 HTML 파일이 존재
3. **서버는 파일만 전달** → 렌더링 작업 없음, 매우 빠름

### SSG vs SSR 비교

| 항목                | SSR                | SSG               |
| ------------------- | ------------------ | ----------------- |
| **HTML 생성 시점**  | 요청이 올 때마다   | 빌드할 때 한 번만 |
| **서버 작업**       | 매 요청마다 렌더링 | 파일만 전달       |
| **응답 시간**       | 200-500ms          | 10-50ms           |
| **서버 부하**       | 높음               | 없음              |
| **데이터 업데이트** | 즉시 반영          | 재빌드 필요       |

### SSG 사용 시 주의사항

#### ❌ 동적 콘텐츠는 불가능

```javascript
// ❌ 불가능: 사용자마다 다른 내용
<div>안녕하세요, {currentUser.name}님!</div>

// ✅ 가능: 모든 사용자에게 같은 내용
<div>안녕하세요, 쇼핑몰입니다!</div>
```

#### ❌ 실시간 데이터는 클라이언트에서 처리

```javascript
// SSG로 생성된 HTML에는 정적 데이터만
<div>가격: {product.price}원</div>;

// 실시간 재고는 클라이언트에서 업데이트
useEffect(() => {
  fetchStock(product.id).then(setStock); // 클라이언트에서 실행
}, []);
```

---

## 실무 적용 예시

### 쇼핑몰 하이브리드 전략

현실적인 쇼핑몰은 세 가지 방식을 모두 사용합니다:

```
┌─────────────────────────────────────────┐
│ 홈페이지 (/): SSR                       │
│ 이유: 검색어/필터에 따라 다른 상품 표시  │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 상품 상세 (/products/123): SSG          │
│ 이유: 상품 정보는 자주 안 바뀜, 빠른    │
│       로딩 + SEO 중요                    │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 장바구니 (/cart): CSR                   │
│ 이유: 사용자마다 다른 내용, SEO 불필요   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 검색 결과 (/search?q=노트북): SSR       │
│ 이유: 검색어마다 다른 결과, SEO 중요     │
└─────────────────────────────────────────┘
```

### 이 과제에서의 구현 예시

#### 1. 홈페이지 (SSR)

```javascript
// packages/vanilla/server.js
app.get("/", async (req, res) => {
  // 요청마다 다른 상품 표시 (검색어, 필터 등)
  const query = req.query; // { search: "노트북", page: "1" }
  const html = await render(req.url, query);
  res.send(html);
});
```

#### 2. 상품 상세 페이지 (SSG)

```javascript
// packages/vanilla/static-site-generate.js
async function generateStaticSite() {
  // 모든 상품 데이터 가져오기
  const products = await fetchAllProducts();

  // 각 상품마다 HTML 파일 생성
  for (const product of products) {
    const html = await render(`/products/${product.id}`, {});

    // 파일로 저장
    const dir = `dist/products/${product.id}`;
    fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(`${dir}/index.html`, html);
  }
}
```

**결과:**

```
dist/
  ├── index.html (홈페이지)
  └── products/
      ├── 1/
      │   └── index.html (상품 1)
      ├── 2/
      │   └── index.html (상품 2)
      └── ...
```

#### 3. 장바구니 (CSR)

```javascript
// packages/vanilla/src/main.js
// 기존 방식 유지 (클라이언트에서 렌더링)
function main() {
  initRender();
  router.start();
}
```


## 성능 비교 정리

### 실제 측정 데이터 (예시)

#### 홈페이지 로딩 시간

| 방식 | 첫 화면 표시 | 인터랙티브 가능 | SEO | 서버 부하 |
| ---- | ------------ | --------------- | --- | --------- |
| CSR  | 3-5초        | 3-5초           | ❌  | 낮음      |
| SSR  | 0.5-1초      | 1.5초           | ✅  | 높음      |
| SSG  | 0.1-0.3초    | 0.5초           | ✅  | 없음      |

#### 서버 부하 (초당 1000 요청)

| 방식 | CPU 사용률 | 메모리 사용 | 응답 시간 |
| ---- | ---------- | ----------- | --------- |
| CSR  | 10%        | 500MB       | 50ms      |
| SSR  | 80%        | 2GB         | 300ms     |
| SSG  | 5%         | 200MB       | 20ms      |

---

## 결론

### 왜 이 과제를 냈을까?

1. **CSR의 한계를 직접 체험**
   - 이론으로만 알고 있던 문제를 실제로 경험
   - 왜 SSR/SSG가 필요한지 몸으로 느끼기

2. **실무에서 바로 적용 가능한 지식**
   - 쇼핑몰처럼 SEO가 중요한 서비스
   - 어떤 페이지에 어떤 방식을 쓸지 판단하는 능력

3. **프레임워크를 더 잘 이해하기**
   - Next.js가 내부적으로 하는 일을 직접 구현
   - 프레임워크 없이도 SSR/SSG 구현 가능

4. **성능 최적화 사고**
   - 사용자 경험 개선을 위한 렌더링 전략
   - 트레이드오프를 이해하고 선택하는 능력

### 핵심 메시지

> **"올바른 렌더링 전략은 상황에 따라 다르다"**
>
> - 모든 페이지를 SSR로 만들 필요 없음
> - 모든 페이지를 SSG로 만들 필요 없음
> - 모든 페이지를 CSR로 만들 필요 없음
>
> **각 페이지의 특성을 분석하고, 가장 적합한 렌더링 방식을 선택하라.**
>
> 이것이 바로 이 과제를 통해 배워야 할 핵심 능력입니다.

---

## 요약 체크리스트

### CSR

- ✅ 빠른 페이지 전환
- ❌ 초기 로딩 느림
- ❌ SEO 안 됨
- ❌ 소셜 공유 미리보기 안 됨
- ✅ 서버 부하 낮음

### SSR

- ✅ 초기 로딩 빠름
- ✅ SEO 완벽
- ✅ 소셜 공유 미리보기 완벽
- ❌ 서버 부하 높음
- ❌ 응답 시간이 느려질 수 있음

### SSG

- ✅ 극도로 빠른 응답
- ✅ SEO 완벽
- ✅ 소셜 공유 미리보기 완벽
- ✅ 서버 부하 제로
- ❌ 데이터 업데이트 시 재빌드 필요
- ❌ 동적 콘텐츠에 부적합

**결론:** 세 가지를 모두 적절히 조합하여 사용하라!
