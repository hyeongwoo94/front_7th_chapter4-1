# SSR 초기 데이터 window.__INITIAL_DATA__ 테스트 디버깅 명세서

## 문제 상황

### 테스트 실패 내용
- **테스트명**: `SSR에서 초기 데이터가 window.__INITIAL_DATA__에 포함된다`
- **위치**: `e2e/createTests.ts` 681-689줄
- **실패 원인**: `expect(html).toContain(...)` 에서 예상 문자열을 찾지 못함

### 테스트가 기대하는 JSON 형식
```json
{
  "products": [{"title": "..."}, ...],
  "categories": {...},
  "totalCount": 340
}
```

테스트 코드는 HTML에서 다음 문자열을 찾습니다:
```
"products":[{"title":"PVC 투명 젤리 쇼핑백...
```

### 실제 코드가 생성하는 JSON 형식
```json
{
  "productStore": {
    "products": [{"title": "..."}, ...],
    "categories": {...},
    "totalCount": 340
  },
  "cartStore": {...},
  "uiStore": {...}
}
```

실제 HTML에는 다음 형식으로 존재:
```
{"productStore":{"products":[{"title":"PVC 투명 젤리 쇼핑백...
```

## 핵심 문제

1. **구조 불일치**: 테스트는 최상위 레벨에 `products`를 기대하지만, 실제는 `productStore.products`로 중첩되어 있음
2. **문자열 매칭 실패**: 테스트가 찾는 `"products":[{"title":"...`는 실제 HTML에 `{"productStore":{"products":[{"title":"...`로 존재

## 수정 방법 시도 기록

### ✅ 옵션 1: initialState 구조 변경 (테스트 기대 형식에 맞추기)
- **목표**: `initialState`를 테스트가 기대하는 형식으로 변경
- **방법**: 최상위 레벨에 `products`, `categories`, `totalCount`를 직접 배치
- **위치**: `packages/vanilla/src/main-server.js` 428-449줄
- **상태**: ✅ 완료
- **변경 내용**:
  - 최상위 레벨에 `products`, `categories`, `totalCount` 추가
  - 클라이언트 호환성을 위해 기존 `productStore` 구조도 유지
  - JSON 직렬화 시 `products`가 첫 번째 속성이 되도록 보장

### ⏸️ 옵션 2: 테스트 코드 수정
- **제약사항**: 사용자가 테스트 코드 수정 금지 요청
- **상태**: 옵션 1 실패 시 검토

## 진행 상황

- [x] 옵션 1 시도: initialState 구조 변경
  - **변경 내용**: 최상위 레벨에 `products`, `categories`, `totalCount`를 직접 배치
  - **호환성**: 클라이언트 호환성을 위해 기존 `productStore` 구조도 유지
  - **위치**: `packages/vanilla/src/main-server.js` 428-455줄
  - **예상 JSON 형식**: `{"products":[...], "categories":{...}, "totalCount":340, "productStore":{...}, ...}`
  - **테스트 매칭**: `"products":[{"title":"...` 문자열이 HTML에 포함되어야 함
- [ ] 옵션 1 테스트 실행 및 결과 확인
- [ ] 필요시 옵션 2 검토

## 변경된 코드 구조

### 변경 전
```javascript
const initialState = {};
initialState.productStore = productStoreState;
initialState.cartStore = cartState;
initialState.uiStore = uiState;
```

### 변경 후
```javascript
const initialState = {};

// 테스트 형식: 최상위 레벨에 직접 배치
if (currentState.products !== undefined) initialState.products = currentState.products;
if (currentState.categories !== undefined) initialState.categories = currentState.categories;
if (currentState.totalCount !== undefined) initialState.totalCount = currentState.totalCount;

// 클라이언트 호환성을 위한 기존 구조도 유지
initialState.productStore = productStoreState;
initialState.cartStore = cartState;
initialState.uiStore = uiState;
```

## 다음 단계

1. 테스트 서버 실행: `pnpm serve:test`
2. 테스트 실행: `pnpm test:e2e:basic`
3. 결과 확인:
   - ✅ 통과: 옵션 1 성공
   - ❌ 실패: 옵션 2 검토 (테스트 코드 수정 제약사항 고려)

## SSG 테스트 수정

### 상태
- [x] SSR 테스트 통과 확인
- [x] SSG 빌드 재실행 완료
- [x] 생성된 HTML 확인: `window.__INITIAL_DATA__ = {"products":[{"title":"...` 형식 정확히 생성됨
- [ ] SSG 테스트 통과 확인 (테스트 실행 필요)

### SSG 동작 방식
- SSG는 `static-site-generate.js`에서 `main-server.js`의 `render` 함수를 사용
- 이미 수정한 `initialState` 구조가 SSG에도 적용됨
- `htmlUtils.js`의 `injectIntoTemplate` 함수가 `JSON.stringify`로 직렬화

### 필요한 작업
1. SSG 빌드 재실행: 
   - 전체 빌드: `pnpm -F @hanghae-plus/shopping-vanilla build`
   - 또는 SSG만: `pnpm -F @hanghae-plus/shopping-vanilla build:ssg`
   - 또는 테스트 서버 실행 시 자동 빌드: `pnpm serve:test` (이미 실행 중이면 재실행)
2. SSG 테스트 실행: `pnpm test:e2e:basic`
3. 결과 확인

### 확인 사항
- SSG는 `static-site-generate.js`에서 `main-server.js`의 `render` 함수를 호출
- 이미 수정한 `initialState` 구조가 SSG 빌드 타임에도 적용됨
- `htmlUtils.js`의 `injectIntoTemplate`가 `JSON.stringify`로 직렬화하므로 구조 변경이 그대로 반영됨

### 빌드 결과 확인
- ✅ `dist/vanilla/index.html` 파일 확인 완료
- ✅ `window.__INITIAL_DATA__ = {"products":[{"title":"...` 형식 정확히 생성됨
- ✅ 테스트가 찾는 문자열 `"products":[{"title":"...` 포함 확인

## 참고 파일

- 테스트 코드: `e2e/createTests.ts` (681-689줄)
- SSR 렌더링 로직: `packages/vanilla/src/main-server.js` (446-449줄)
- 서버 HTML 삽입: `packages/vanilla/server.js` (214줄)

